# ðŸ”’ Kubesec Security Scanner
# Automated security analysis for Kubernetes manifests
# This workflow uses actions that are not certified by GitHub.

name: ðŸ”’ Home-Ops Security Analysis

on:
  push:
    branches: [ "main" ]
    paths:
      - "kubernetes/**/*.yaml"
      - "kubernetes/**/*.yml"
  pull_request:
    branches: [ "main" ]
    paths:
      - "kubernetes/**/*.yaml"
      - "kubernetes/**/*.yml"
  schedule:
    - cron: '26 23 * * 1'
  workflow_dispatch:

jobs:
  security-scan:
    name: ðŸ›¡ï¸ GitOps Security Analysis
    runs-on: home-ops-runner
    permissions:
      actions: read
      contents: read
      security-events: write
      pull-requests: write

    steps:
      - name: ðŸ“¥ Checkout Repository
        # renovate: datasource=github-tags depName=actions/checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: ðŸ” Discover GitOps Manifests
        id: discover
        run: |
          echo "ðŸ” Discovering GitOps manifests for security analysis..."

          # Find all YAML files in the repository
          find kubernetes/ \
            \( -name "*.yaml" -o -name "*.yml" \) \
            ! -name "kustomization.yaml" \
            ! -name "kustomization.yml" \
            ! -path "*/flux-system/*" \
            > all_manifests.txt

          TOTAL_COUNT=$(wc -l < all_manifests.txt)
          echo "ðŸ“Š Found $TOTAL_COUNT YAML files total"
          echo "total_manifests=$TOTAL_COUNT" >> $GITHUB_OUTPUT

          # Categorize files by type
          echo "ðŸ” Analyzing manifest types..."

          # HelmReleases
          HELM_COUNT=$(grep -l "kind:\s*HelmRelease" kubernetes/**/*.yaml kubernetes/**/*.yml 2>/dev/null | wc -l || echo "0")
          echo "helmrelease_count=$HELM_COUNT" >> $GITHUB_OUTPUT

          # Kustomizations
          KUSTOMIZATION_COUNT=$(grep -l "kind:\s*Kustomization" kubernetes/**/*.yaml kubernetes/**/*.yml 2>/dev/null | wc -l || echo "0")
          echo "kustomization_count=$KUSTOMIZATION_COUNT" >> $GITHUB_OUTPUT

          # ExternalSecrets
          EXTERNALSECRET_COUNT=$(grep -l "kind:\s*ExternalSecret" kubernetes/**/*.yaml kubernetes/**/*.yml 2>/dev/null | wc -l || echo "0")
          echo "externalsecret_count=$EXTERNALSECRET_COUNT" >> $GITHUB_OUTPUT

          echo "ðŸ“Š Manifest breakdown:"
          echo "  ðŸ“¦ HelmReleases: $HELM_COUNT"
          echo "  ðŸ”§ Kustomizations: $KUSTOMIZATION_COUNT"
          echo "  ðŸ” ExternalSecrets: $EXTERNALSECRET_COUNT"

          if [ $TOTAL_COUNT -eq 0 ]; then
            echo "scan_needed=false" >> $GITHUB_OUTPUT
          else
            echo "scan_needed=true" >> $GITHUB_OUTPUT
          fi

          rm -f all_manifests.txt

      - name: ðŸ”’ Initialize Security Scan
        id: init
        if: steps.discover.outputs.scan_needed == 'true'
        run: |
          echo "ðŸ”’ Running custom Home-Ops security analysis..."

          # Initialize counters
          echo "0" > critical_count.txt
          echo "0" > warning_count.txt
          echo "0" > info_count.txt
          echo "0" > privileged_count.txt
          echo "0" > host_network_count.txt
          echo "0" > root_users_count.txt

          # Initialize result files
          touch security_issues.txt
          touch warnings.txt
          touch info_items.txt

      - name: ðŸ“¦ Analyze HelmRelease Security
        if: steps.discover.outputs.scan_needed == 'true'
        run: |
          echo "ðŸ” Analyzing HelmRelease configurations..."

          CRITICAL_COUNT=$(cat critical_count.txt)
          WARNING_COUNT=$(cat warning_count.txt)
          INFO_COUNT=$(cat info_count.txt)

          # Function to check if a file is primarily a HelmRelease (not just containing references)
          is_primary_helmrelease() {
            local file="$1"
            # Check if the first non-comment kind declaration is HelmRelease
            awk '
              /^[[:space:]]*#/ { next }                    # Skip comments
              /^[[:space:]]*kind:[[:space:]]*HelmRelease/ { print "true"; exit }
              /^[[:space:]]*kind:[[:space:]]*/ { print "false"; exit }
              /^[[:space:]]*apiVersion:/ { api_found=1; next }
              api_found && /^[[:space:]]*kind:[[:space:]]*HelmRelease/ { print "true"; exit }
              api_found && /^[[:space:]]*kind:[[:space:]]*/ { print "false"; exit }
            ' "$file" 2>/dev/null
          }

          # Function to get line number for a pattern match
          get_line_number() {
            local file="$1"
            local pattern="$2"
            grep -n "$pattern" "$file" 2>/dev/null | head -1 | cut -d: -f1 | tr -d '\n'
          }

          # Check for insecure HelmRelease configurations - ONLY in actual HelmRelease files
          while IFS= read -r helmrelease; do
            echo "ðŸ“¦ Scanning potential HelmRelease: $helmrelease"

            # Verify this is actually a primary HelmRelease file
            if [[ "$(is_primary_helmrelease "$helmrelease")" != "true" ]]; then
              echo "â­ï¸ Skipping $helmrelease - not a primary HelmRelease (likely a reference or different resource type)"
              continue
            fi

            echo "âœ… Confirmed HelmRelease file: $helmrelease"

            # Check for missing security contexts in values
            if ! grep -q "securityContext\|runAsNonRoot\|runAsUser" "$helmrelease" 2>/dev/null; then
              LINE_NUM=$(get_line_number "$helmrelease" "spec:\|values:")
              LINE_NUM=${LINE_NUM:-1}
              echo "$helmrelease:$LINE_NUM No securityContext found in HelmRelease values" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

            # Check for missing resource limits
            if ! grep -q "resources:\|limits:\|requests:" "$helmrelease" 2>/dev/null; then
              LINE_NUM=$(get_line_number "$helmrelease" "spec:\|values:")
              LINE_NUM=${LINE_NUM:-1}
              echo "$helmrelease:$LINE_NUM No resource limits specified in HelmRelease" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

            # Check for potential privileged access
            if PRIV_LINE=$(grep -n "privileged.*true\|allowPrivilegeEscalation.*true" "$helmrelease" 2>/dev/null | head -1); then
              LINE_NUM=$(echo "$PRIV_LINE" | cut -d: -f1)
              echo "$helmrelease:$LINE_NUM Privileged container configuration detected in HelmRelease" >> security_issues.txt
              CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            fi

            # Check for hostNetwork
            if HOST_LINE=$(grep -n "hostNetwork.*true" "$helmrelease" 2>/dev/null | head -1); then
              LINE_NUM=$(echo "$HOST_LINE" | cut -d: -f1)
              echo "$helmrelease:$LINE_NUM Host network access enabled in HelmRelease" >> security_issues.txt
              CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            fi

            # Check for hostPath volumes
            if HOSTPATH_LINE=$(grep -n "hostPath:" "$helmrelease" 2>/dev/null | head -1); then
              LINE_NUM=$(echo "$HOSTPATH_LINE" | cut -d: -f1)
              echo "$helmrelease:$LINE_NUM Host path volume detected in HelmRelease" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

            # Check for latest image tags
            if LATEST_LINE=$(grep -n "tag:\s*['\"]latest['\"]" "$helmrelease" 2>/dev/null | head -1); then
              LINE_NUM=$(echo "$LATEST_LINE" | cut -d: -f1)
              echo "$helmrelease:$LINE_NUM Using 'latest' image tag in HelmRelease - use specific versions" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

          done < <(find kubernetes/ -name "*.yaml" -exec grep -l "kind:\s*HelmRelease" {} \; 2>/dev/null)

          echo "$CRITICAL_COUNT" > critical_count.txt
          echo "$WARNING_COUNT" > warning_count.txt
          echo "$INFO_COUNT" > info_count.txt

      - name: ðŸ”— Analyze Flux Source Security
        if: steps.discover.outputs.scan_needed == 'true'
        run: |
          echo "ðŸ” Analyzing Flux Source Security..."

          CRITICAL_COUNT=$(cat critical_count.txt)
          WARNING_COUNT=$(cat warning_count.txt)
          INFO_COUNT=$(cat info_count.txt)

          # Function to check if a file is primarily a specific resource type
          is_primary_resource() {
            local file="$1"
            local resource_type="$2"
            # Check if the first non-comment kind declaration matches the resource type
            awk -v resource="$resource_type" '
              /^[[:space:]]*#/ { next }                    # Skip comments
              /^[[:space:]]*kind:[[:space:]]*/ {
                if ($0 ~ "kind:[[:space:]]*" resource) { print "true"; exit }
                else { print "false"; exit }
              }
              /^[[:space:]]*apiVersion:/ { api_found=1; next }
              api_found && /^[[:space:]]*kind:[[:space:]]*/ {
                if ($0 ~ "kind:[[:space:]]*" resource) { print "true"; exit }
                else { print "false"; exit }
              }
            ' "$file" 2>/dev/null
          }

          # Function to get line number for a pattern match
          get_line_number() {
            local file="$1"
            local pattern="$2"
            grep -n "$pattern" "$file" 2>/dev/null | head -1 | cut -d: -f1 | tr -d '\n'
          }

          # Check HelmRepository sources
          while IFS= read -r helmrepo; do
            echo "ðŸ“¦ Scanning potential HelmRepository: $helmrepo"

            # Verify this is actually a primary HelmRepository file
            if [[ "$(is_primary_resource "$helmrepo" "HelmRepository")" != "true" ]]; then
              echo "â­ï¸ Skipping $helmrepo - not a primary HelmRepository"
              continue
            fi

            echo "âœ… Confirmed HelmRepository file: $helmrepo"

            # Check for HTTPS URLs
            if ! grep -q "url:\s*https://" "$helmrepo" 2>/dev/null; then
              LINE_NUM=$(get_line_number "$helmrepo" "url:")
              LINE_NUM=${LINE_NUM:-1}
              echo "$helmrepo:$LINE_NUM HelmRepository not using HTTPS" >> security_issues.txt
              CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            fi

            # Check for signature verification
            if ! grep -q "verify:\|secretRef:" "$helmrepo" 2>/dev/null; then
              LINE_NUM=$(get_line_number "$helmrepo" "spec:")
              LINE_NUM=${LINE_NUM:-1}
              echo "$helmrepo:$LINE_NUM No signature verification configured" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

          done < <(find kubernetes/ -name "*.yaml" -exec grep -l "kind:\s*HelmRepository" {} \; 2>/dev/null)

          # Check GitRepository sources
          while IFS= read -r gitrepo; do
            echo "ðŸ“‚ Scanning potential GitRepository: $gitrepo"

            # Verify this is actually a primary GitRepository file
            if [[ "$(is_primary_resource "$gitrepo" "GitRepository")" != "true" ]]; then
              echo "â­ï¸ Skipping $gitrepo - not a primary GitRepository"
              continue
            fi

            echo "âœ… Confirmed GitRepository file: $gitrepo"

            # Check for HTTPS URLs
            if ! grep -q "url:\s*https://" "$gitrepo" 2>/dev/null; then
              LINE_NUM=$(get_line_number "$gitrepo" "url:")
              LINE_NUM=${LINE_NUM:-1}
              echo "$gitrepo:$LINE_NUM GitRepository not using HTTPS" >> security_issues.txt
              CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            fi

            # Check for GPG verification
            if ! grep -q "verify:\|secretRef:" "$gitrepo" 2>/dev/null; then
              LINE_NUM=$(get_line_number "$gitrepo" "spec:")
              LINE_NUM=${LINE_NUM:-1}
              echo "$gitrepo:$LINE_NUM No GPG verification configured" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

          done < <(find kubernetes/ -name "*.yaml" -exec grep -l "kind:\s*GitRepository" {} \; 2>/dev/null)

          # Check OCIRepository sources
          while IFS= read -r ocirepo; do
            echo "ðŸ³ Scanning potential OCIRepository: $ocirepo"

            # Verify this is actually a primary OCIRepository file
            if [[ "$(is_primary_resource "$ocirepo" "OCIRepository")" != "true" ]]; then
              echo "â­ï¸ Skipping $ocirepo - not a primary OCIRepository"
              continue
            fi

            echo "âœ… Confirmed OCIRepository file: $ocirepo"

            # Check for signature verification
            if ! grep -q "verify:" "$ocirepo" 2>/dev/null; then
              LINE_NUM=$(get_line_number "$ocirepo" "spec:")
              LINE_NUM=${LINE_NUM:-1}
              echo "$ocirepo:$LINE_NUM No OCI signature verification configured - add verify section with cosign provider" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

          done < <(find kubernetes/ -name "*.yaml" -exec grep -l "kind:\s*OCIRepository" {} \; 2>/dev/null)

          echo "$CRITICAL_COUNT" > critical_count.txt
          echo "$WARNING_COUNT" > warning_count.txt
          echo "$INFO_COUNT" > info_count.txt

      - name: ðŸ” Analyze ExternalSecret Security
        if: steps.discover.outputs.scan_needed == 'true'
        run: |
          echo "ðŸ” Analyzing ExternalSecret configurations..."

          CRITICAL_COUNT=$(cat critical_count.txt)
          WARNING_COUNT=$(cat warning_count.txt)
          INFO_COUNT=$(cat info_count.txt)

          # Function to check if a file is primarily an ExternalSecret
          is_primary_externalsecret() {
            local file="$1"
            # Check if the first non-comment kind declaration is ExternalSecret
            awk '
              /^[[:space:]]*#/ { next }                    # Skip comments
              /^[[:space:]]*kind:[[:space:]]*ExternalSecret/ { print "true"; exit }
              /^[[:space:]]*kind:[[:space:]]*/ { print "false"; exit }
              /^[[:space:]]*apiVersion:/ { api_found=1; next }
              api_found && /^[[:space:]]*kind:[[:space:]]*ExternalSecret/ { print "true"; exit }
              api_found && /^[[:space:]]*kind:[[:space:]]*/ { print "false"; exit }
            ' "$file" 2>/dev/null
          }

          # Function to get line number for a pattern match
          get_line_number() {
            local file="$1"
            local pattern="$2"
            grep -n "$pattern" "$file" 2>/dev/null | head -1 | cut -d: -f1 | tr -d '\n'
          }

          # Check ExternalSecret security
          while IFS= read -r externalsecret; do
            echo "ðŸ” Scanning potential ExternalSecret: $externalsecret"

            # Verify this is actually a primary ExternalSecret file
            if [[ "$(is_primary_externalsecret "$externalsecret")" != "true" ]]; then
              echo "â­ï¸ Skipping $externalsecret - not a primary ExternalSecret"
              continue
            fi

            echo "âœ… Confirmed ExternalSecret file: $externalsecret"

            # Check for proper secret store references
            if ! grep -q "secretStoreRef\|clusterSecretStoreRef" "$externalsecret" 2>/dev/null; then
              LINE_NUM=$(get_line_number "$externalsecret" "spec:")
              LINE_NUM=${LINE_NUM:-1}
              echo "$externalsecret:$LINE_NUM Missing secret store reference" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

          done < <(find kubernetes/ -name "*.yaml" -exec grep -l "kind:\s*ExternalSecret" {} \; 2>/dev/null)

          echo "$CRITICAL_COUNT" > critical_count.txt
          echo "$WARNING_COUNT" > warning_count.txt
          echo "$INFO_COUNT" > info_count.txt

      - name: ðŸ›¡ï¸ Analyze RBAC Security
        if: steps.discover.outputs.scan_needed == 'true'
        run: |
          echo "ðŸ›¡ï¸ Performing RBAC Security Analysis..."

          CRITICAL_COUNT=$(cat critical_count.txt)
          WARNING_COUNT=$(cat warning_count.txt)
          INFO_COUNT=$(cat info_count.txt)

          # Function to check if a file is primarily an RBAC resource
          is_primary_rbac() {
            local file="$1"
            # Check if the first non-comment kind declaration is RBAC-related
            awk '
              /^[[:space:]]*#/ { next }                    # Skip comments
              /^[[:space:]]*kind:[[:space:]]*(Role|ClusterRole|RoleBinding|ClusterRoleBinding|ServiceAccount)([[:space:]]|$)/ { print "true"; exit }
              /^[[:space:]]*kind:[[:space:]]*/ { print "false"; exit }
              /^[[:space:]]*apiVersion:/ { api_found=1; next }
              api_found && /^[[:space:]]*kind:[[:space:]]*(Role|ClusterRole|RoleBinding|ClusterRoleBinding|ServiceAccount)([[:space:]]|$)/ { print "true"; exit }
              api_found && /^[[:space:]]*kind:[[:space:]]*/ { print "false"; exit }
            ' "$file" 2>/dev/null
          }

          # Function to get line number for a pattern match
          get_line_number() {
            local file="$1"
            local pattern="$2"
            grep -n "$pattern" "$file" 2>/dev/null | head -1 | cut -d: -f1 | tr -d '\n'
          }

          # Check ServiceAccounts and Roles
          while IFS= read -r rbacfile; do
            echo "ðŸ”‘ Scanning potential RBAC resource: $rbacfile"

            # Verify this is actually a primary RBAC resource file
            if [[ "$(is_primary_rbac "$rbacfile")" != "true" ]]; then
              echo "â­ï¸ Skipping $rbacfile - not a primary RBAC resource"
              continue
            fi

            echo "âœ… Confirmed RBAC resource file: $rbacfile"

            # Check for wildcard permissions
            if WILDCARD_LINE=$(grep -n "resources:\s*\[.*\*.*\]" "$rbacfile" 2>/dev/null | head -1); then
              LINE_NUM=$(echo "$WILDCARD_LINE" | cut -d: -f1)
              echo "$rbacfile:$LINE_NUM Wildcard (*) permissions detected" >> security_issues.txt
              CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            fi

            # Check for cluster-admin role
            if ADMIN_LINE=$(grep -n "cluster-admin" "$rbacfile" 2>/dev/null | head -1); then
              LINE_NUM=$(echo "$ADMIN_LINE" | cut -d: -f1)
              echo "$rbacfile:$LINE_NUM cluster-admin role binding found" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            fi

          done < <(find kubernetes/ -name "*.yaml" -exec grep -l "kind:\s*\(Role\|ClusterRole\|RoleBinding\|ClusterRoleBinding\|ServiceAccount\)" {} \; 2>/dev/null)

          echo "$CRITICAL_COUNT" > critical_count.txt
          echo "$WARNING_COUNT" > warning_count.txt
          echo "$INFO_COUNT" > info_count.txt

      - name: ðŸ” Analyze Container Security
        if: steps.discover.outputs.scan_needed == 'true'
        run: |
          echo "ï¿½ Analyzing container security patterns..."

          CRITICAL_COUNT=$(cat critical_count.txt)
          WARNING_COUNT=$(cat warning_count.txt)
          PRIVILEGED_COUNT=$(cat privileged_count.txt)
          HOST_NETWORK_COUNT=$(cat host_network_count.txt)
          ROOT_USER_COUNT=$(cat root_users_count.txt)

          # Check for hardcoded secrets/tokens
          if HARDCODED_SECRETS=$(grep -r -i -E "(password|token|key|secret):\s*['\"]?[a-zA-Z0-9]{8,}" kubernetes/ --include="*.yaml" --include="*.yml" 2>/dev/null | grep -v "secretRef\|valueFrom\|secretKeyRef" | head -5); then
            if [ ! -z "$HARDCODED_SECRETS" ]; then
              echo "kubernetes/: Potential hardcoded secrets detected in YAML files" >> security_issues.txt
              CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            fi
          fi

          # Check for privileged containers
          if PRIVILEGED_FILES=$(grep -r -l "privileged.*true" kubernetes/ 2>/dev/null); then
            PRIVILEGED_COUNT=$(echo "$PRIVILEGED_FILES" | wc -l)
            echo "$PRIVILEGED_FILES" | while read -r file; do
              echo "$file: Privileged container configuration detected" >> security_issues.txt
              CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            done
          fi

          # Check for hostNetwork usage
          if HOST_NETWORK_FILES=$(grep -r -l "hostNetwork.*true" kubernetes/ 2>/dev/null); then
            HOST_NETWORK_COUNT=$(echo "$HOST_NETWORK_FILES" | wc -l)
            echo "$HOST_NETWORK_FILES" | while read -r file; do
              echo "$file: Host network access enabled" >> security_issues.txt
              CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            done
          fi

          # Check for root users
          if ROOT_USER_FILES=$(grep -r -l "runAsUser.*0" kubernetes/ 2>/dev/null); then
            ROOT_USER_COUNT=$(echo "$ROOT_USER_FILES" | wc -l)
            echo "$ROOT_USER_FILES" | while read -r file; do
              echo "$file: Container running as root user" >> warnings.txt
              WARNING_COUNT=$((WARNING_COUNT + 1))
            done
          fi

          echo "$CRITICAL_COUNT" > critical_count.txt
          echo "$WARNING_COUNT" > warning_count.txt
          echo "$PRIVILEGED_COUNT" > privileged_count.txt
          echo "$HOST_NETWORK_COUNT" > host_network_count.txt
          echo "$ROOT_USER_COUNT" > root_users_count.txt

      - name: ðŸ“‹ Generate SARIF Results
        id: sarif
        if: steps.discover.outputs.scan_needed == 'true'
        run: |
          echo "ðŸ“‹ Generating comprehensive SARIF results..."

          CRITICAL_COUNT=$(cat critical_count.txt)
          WARNING_COUNT=$(cat warning_count.txt)
          INFO_COUNT=$(cat info_count.txt)
          PRIVILEGED_COUNT=$(cat privileged_count.txt)
          HOST_NETWORK_COUNT=$(cat host_network_count.txt)
          ROOT_USER_COUNT=$(cat root_users_count.txt)

          SARIF_RESULTS=""

          # Function to create stable fingerprint
          create_fingerprint() {
            local file_path="$1"
            local message="$2"
            local rule_id="$3"
            echo "${rule_id}:${file_path}:${message}" | sha256sum | cut -d' ' -f1
          }

          # Process critical security issues
          if [ -f security_issues.txt ] && [ -s security_issues.txt ]; then
            while IFS= read -r issue; do
              if [[ "$issue" == *":"* ]]; then
                # Parse file:line:message format
                file_and_line=$(echo "$issue" | cut -d: -f1,2)
                file_path=$(echo "$file_and_line" | cut -d: -f1)
                line_num=$(echo "$file_and_line" | cut -d: -f2)
                message=$(echo "$issue" | cut -d: -f3- | sed 's/"/\\"/g' | sed 's/^ *//')

                # Validate line number is numeric, default to 1 if not
                if ! [[ "$line_num" =~ ^[0-9]+$ ]]; then
                  line_num=1
                fi

                # Only add if file exists and path is valid
                if [ -f "$file_path" ]; then
                  fingerprint=$(create_fingerprint "$file_path" "$message" "critical-security")
                  SARIF_RESULTS="$SARIF_RESULTS{\"ruleId\":\"critical-security\",\"level\":\"error\",\"message\":{\"text\":\"$message\"},\"locations\":[{\"physicalLocation\":{\"artifactLocation\":{\"uri\":\"$file_path\"},\"region\":{\"startLine\":$line_num}}}],\"fingerprints\":{\"home-ops-security\":\"$fingerprint\"}},"
                fi
              fi
            done < security_issues.txt
          fi

          # Process warnings - only file-specific ones
          if [ -f warnings.txt ] && [ -s warnings.txt ]; then
            while IFS= read -r warning; do
              if [[ "$warning" == *":"* ]]; then
                # Parse file:line:message format
                file_and_line=$(echo "$warning" | cut -d: -f1,2)
                file_path=$(echo "$file_and_line" | cut -d: -f1)
                line_num=$(echo "$file_and_line" | cut -d: -f2)
                message=$(echo "$warning" | cut -d: -f3- | sed 's/"/\\"/g' | sed 's/^ *//')

                # Validate line number is numeric, default to 1 if not
                if ! [[ "$line_num" =~ ^[0-9]+$ ]]; then
                  line_num=1
                fi

                # Only add if file exists and path is valid
                if [ -f "$file_path" ]; then
                  fingerprint=$(create_fingerprint "$file_path" "$message" "security-warning")
                  SARIF_RESULTS="$SARIF_RESULTS{\"ruleId\":\"security-warning\",\"level\":\"warning\",\"message\":{\"text\":\"$message\"},\"locations\":[{\"physicalLocation\":{\"artifactLocation\":{\"uri\":\"$file_path\"},\"region\":{\"startLine\":$line_num}}}],\"fingerprints\":{\"home-ops-security\":\"$fingerprint\"}},"
                fi
              fi
            done < warnings.txt
          fi

          # Remove trailing comma if results exist
          if [ ! -z "$SARIF_RESULTS" ]; then
            SARIF_RESULTS=${SARIF_RESULTS%,}
          fi

          # Add timestamp to make fingerprints more stable across runs
          SCAN_TIMESTAMP=$(date -u '+%Y%m%d')

          cat > security-results.sarif << EOF
          {
            "version": "2.1.0",
            "\$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0.json",
            "runs": [
              {
                "tool": {
                  "driver": {
                    "name": "home-ops-security-scanner",
                    "version": "2.0.0",
                    "informationUri": "https://github.com/vrozaksen/home-ops",
                    "shortDescription": {
                      "text": "Custom GitOps security scanner for home-ops repository"
                    },
                    "properties": {
                      "scanTimestamp": "$SCAN_TIMESTAMP"
                    },
                    "rules": [
                      {
                        "id": "critical-security",
                        "name": "Critical Security Issue",
                        "shortDescription": {
                          "text": "Critical security configuration issue requiring immediate attention"
                        },
                        "defaultConfiguration": {
                          "level": "error"
                        },
                        "help": {
                          "text": "This rule identifies critical security misconfigurations in Kubernetes manifests that require immediate attention."
                        }
                      },
                      {
                        "id": "security-warning",
                        "name": "Security Warning",
                        "shortDescription": {
                          "text": "Security configuration warning that should be reviewed"
                        },
                        "defaultConfiguration": {
                          "level": "warning"
                        },
                        "help": {
                          "text": "This rule identifies security configurations that could be improved but are not immediately critical."
                        }
                      }
                    ]
                  }
                },
                "results": [$SARIF_RESULTS]
              }
            ]
          }
          EOF

          echo "âœ… Home-Ops security scan completed!"
          echo "ðŸ“Š Security Analysis Complete"
          echo "ðŸ”´ Critical Issues: $CRITICAL_COUNT"
          echo "ðŸŸ¡ Warnings: $WARNING_COUNT"
          echo "â„¹ï¸  Info: $INFO_COUNT"

          # Output results for summary
          echo "critical_count=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
          echo "warning_count=$WARNING_COUNT" >> $GITHUB_OUTPUT
          echo "info_count=$INFO_COUNT" >> $GITHUB_OUTPUT
          echo "scanned_count=${{ steps.discover.outputs.total_manifests }}" >> $GITHUB_OUTPUT
          echo "privileged_containers=$PRIVILEGED_COUNT" >> $GITHUB_OUTPUT
          echo "host_network=$HOST_NETWORK_COUNT" >> $GITHUB_OUTPUT
          echo "root_users=$ROOT_USER_COUNT" >> $GITHUB_OUTPUT

          # Generate security summary
          ADDITIONAL_ISSUES=""
          if [ $PRIVILEGED_COUNT -gt 0 ]; then
            ADDITIONAL_ISSUES="${ADDITIONAL_ISSUES}Privileged containers: $PRIVILEGED_COUNT files; "
          fi
          if [ $HOST_NETWORK_COUNT -gt 0 ]; then
            ADDITIONAL_ISSUES="${ADDITIONAL_ISSUES}HostNetwork usage: $HOST_NETWORK_COUNT files; "
          fi
          if [ $ROOT_USER_COUNT -gt 0 ]; then
            ADDITIONAL_ISSUES="${ADDITIONAL_ISSUES}Root users: $ROOT_USER_COUNT files; "
          fi

          if [ -z "$ADDITIONAL_ISSUES" ]; then
            SECURITY_SUMMARY="âœ… All security checks passed"
          else
            SECURITY_SUMMARY="âš ï¸ Security issues found: $ADDITIONAL_ISSUES"
          fi
          echo "security_summary=$SECURITY_SUMMARY" >> $GITHUB_OUTPUT

      - name:  Generate Scan Summary
        if: steps.discover.outputs.scan_needed == 'true'
        run: |
          echo "## ðŸ”’ Home-Ops Security Analysis Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ  **Repository**: GitOps Home Operations" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“ **Analyzed**: ${{ steps.discover.outputs.total_manifests }} YAML manifests" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ•’ **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### ðŸ“¦ Manifest Breakdown" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Type | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|---------------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| ï¿½ HelmReleases | ${{ steps.discover.outputs.helmrelease_count || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”§ Kustomizations | ${{ steps.discover.outputs.kustomization_count || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ” ExternalSecrets | ${{ steps.discover.outputs.externalsecret_count || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### ðŸ” Security Analysis Results" >> $GITHUB_STEP_SUMMARY
          echo "| Severity | Count | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”´ Critical | ${{ steps.sarif.outputs.critical_count || '0' }} | ${{ steps.sarif.outputs.critical_count == '0' && 'âœ… None Found' || 'âš ï¸ Requires Attention' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¡ Warnings | ${{ steps.sarif.outputs.warning_count || '0' }} | ${{ steps.sarif.outputs.warning_count == '0' && 'âœ… None Found' || 'ðŸ’¡ Recommendations' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¢ Info | ${{ steps.sarif.outputs.info_count || '0' }} | ${{ steps.sarif.outputs.info_count == '0' && 'âœ… None Found' || 'ðŸ“‹ Suggestions' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### ðŸ” Specific Security Checks" >> $GITHUB_STEP_SUMMARY
          echo "| Security Check | Count | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Privileged Containers | ${{ steps.sarif.outputs.privileged_containers || '0' }} | ${{ steps.sarif.outputs.privileged_containers == '0' && 'âœ… Safe' || 'âš ï¸ Issues Found' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Host Network Usage | ${{ steps.sarif.outputs.host_network || '0' }} | ${{ steps.sarif.outputs.host_network == '0' && 'âœ… Safe' || 'âš ï¸ Issues Found' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Root User Containers | ${{ steps.sarif.outputs.root_users || '0' }} | ${{ steps.sarif.outputs.root_users == '0' && 'âœ… Safe' || 'âš ï¸ Issues Found' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Overall Security Status:** ${{ steps.sarif.outputs.security_summary || 'No security scan data available' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "ðŸŽ¯ **Scanner**: Custom Home-Ops GitOps Security Analysis" >> $GITHUB_STEP_SUMMARY
          echo "ï¿½ **Runner**: home-ops-runner" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ“¤ Upload Security Results
        id: check_sarif
        if: steps.discover.outputs.scan_needed == 'true' && always()
        run: |
          # Check if we have any SARIF results to upload
          if [ -f "security-results.sarif" ]; then
            RESULT_COUNT=$(jq '.runs[0].results | length' security-results.sarif 2>/dev/null || echo "0")
            echo "ðŸ“Š SARIF file contains $RESULT_COUNT security results"

            if [ "$RESULT_COUNT" -gt 0 ]; then
              echo "ðŸ“¤ Uploading security results to GitHub Security tab..."
              echo "sarif_upload_needed=true" >> $GITHUB_OUTPUT
            else
              echo "â­ï¸ No security results to upload - skipping SARIF upload"
              echo "sarif_upload_needed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âŒ SARIF file not found - skipping upload"
            echo "sarif_upload_needed=false" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“¤ Upload SARIF to GitHub Security
        if: steps.discover.outputs.scan_needed == 'true' && always() && steps.check_sarif.outputs.sarif_upload_needed == 'true'
        # renovate: datasource=github-tags depName=github/codeql-action
        uses: github/codeql-action/upload-sarif@4e828ff8d448a8a6e532957b1811f387a63867e8 # v3.29.4
        with:
          sarif_file: security-results.sarif
          category: home-ops-security

      - name: âš ï¸ Skip Notification
        if: steps.discover.outputs.scan_needed == 'false'
        run: |
          echo "## ðŸ”’ Home-Ops Security Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "â„¹ï¸ **No YAML manifests found to analyze**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This is unexpected for a GitOps repository. Please check:" >> $GITHUB_STEP_SUMMARY
          echo "- The kubernetes/ directory exists" >> $GITHUB_STEP_SUMMARY
          echo "- YAML files are present in the repository" >> $GITHUB_STEP_SUMMARY
          echo "- File permissions allow reading" >> $GITHUB_STEP_SUMMARY
